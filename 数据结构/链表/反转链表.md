### 反转链表

#### 实现思路

1. 建立一个新的头结点
2. 使用临时节点保存当前结点的next节点
3. 将当前结点的next节点指向新的头结点
4. 新的头结点等于当前节点
5. 当前节点变更为第二步中保存的临时节点
6. 重复2-5步骤，直到链表结束
7. 返回新的头结点


```C++
class Solution 
{
public:
    ListNode* ReverseList(ListNode* pHead) 
    {
        if(nullptr == pHead || nullptr == pHead->next)
        {
            return pHead;
        }
        ListNode* pPre = nullptr;
        ListNode* pCur = pHead;
        while(pCur)
        {
            ListNode* pNext = pHead->next;
            pHead->next = pPre;
            pPre = pCur;
            pCur = pNext;
        }
        return pPre;
    }
};
```

### 链表中每k个一组翻转

```C++
class Solution 
{
public:
    ListNode* reverse(ListNode* first, ListNode* last)
    {
        ListNode* pre = nullptr;
        ListNode* next = nullptr;
        while(first != last)
        {
            next = first->next;
            first->next = pre;
            pre = first;
            first = next;
        }
        return pre;
    }
    ListNode* reverseKGroup(ListNode* head, int k) 
    {
        if(!head || !head->next || k <= 1)
        {
            return head;
        }
        ListNode* node = head;
        for(int i = 0; i < k; ++i)
        {
            if(!node)
            {
                return head;
            }
            node = node->next;
        }
        ListNode* newHead = reverse(head, node);
        head->next = reverseKGroup(node, k);
        return newHead;
    }
};
```
